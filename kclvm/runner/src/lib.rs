use kclvm_ast::ast::Program;
use kclvm_sema::resolver::scope::ProgramScope;
use runner::{ExecProgramArgs, KclvmRunner, KclvmRunnerOptions};

pub mod assembler;
pub mod command;
pub mod linker;
pub mod runner;

#[cfg(test)]
pub mod tests;

/// After the kcl program passed through kclvm-parser and kclvm-sema in the compiler frontend,
/// KCLVM needs to generate corresponding LLVM IR, dylibs or executable file for kcl program
/// in the compiler backend.
///
/// Method “execute” is the entry point for the compiler backend.
///
/// It returns the KCL program executing result as Result<a_json_string, an_err_string>,
/// and mainly takes "program" (ast.Program returned by kclvm-parser) and "scope"
/// (ProgramScope returned by kclvm-sema) as input.
///
/// "plugin_agent" is related to KCLVM plugin.
/// "args" is the items selected by the user in the KCLVM CLI.
///
/// In the method, dylibs is generated by KclvmAssembler, and method "KclvmAssembler::gen_dylibs"
/// will return dylibs path in a "Vec<String>";
///
/// After linking all dylibs by KclvmLinker, method "KclvmLinker::link_all_dylibs" will return a path
/// for dylib.
///
/// At last, KclvmRunner will be constructed and call method "run" to execute the kcl program.
pub fn execute(
    program: Program,
    scope: ProgramScope,
    plugin_agent: u64,
    args: &ExecProgramArgs,
) -> Result<String, String> {
    // generate dylibs
    let dylib_paths = assembler::KclvmAssembler::gen_dylibs(program, scope, plugin_agent);

    // link dylibsKclvmRunner
    let dylib_path = linker::KclvmLinker::link_all_dylibs(dylib_paths, plugin_agent);

    // run
    let runner = KclvmRunner::new(
        dylib_path.as_str(),
        Some(KclvmRunnerOptions {
            plugin_agent_ptr: plugin_agent,
        }),
    );
    runner.run(&args)
}
