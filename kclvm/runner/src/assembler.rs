use indexmap::IndexMap;
use kclvm_error::bug;
use std::{
    collections::HashMap,
    path::{Path, PathBuf},
    sync::mpsc::channel,
};
use threadpool::ThreadPool;

use crate::command::Command;
use kclvm_ast::ast::{self, Program};
use kclvm_compiler::codegen::{llvm::emit_code, EmitOptions};
use kclvm_config::cache::{load_pkg_cache, save_pkg_cache, CacheOption};
use kclvm_sema::resolver::scope::ProgramScope;

/// LLVM IR file suffix.
const LL_FILE: &str = "_a.out";

/// KclvmAssembler is mainly responsible for assembling the generated bytecode,
/// LLVM IR or other IR code into dynamic link libraries, and take the result of
/// kclvm-parser, kclvm-sema and kclvm-compiler as input.
pub struct KclvmAssembler {
    thread_count: usize,
}
impl KclvmAssembler {
    pub fn new() -> Self {
        Self { thread_count: 4 }
    }

    pub fn new_with_thread_count(thread_count: usize) -> Self {
        if thread_count <= 0 {
            bug!("Illegal Thread Count");
        }
        Self { thread_count }
    }

    /// Generate the dylibs and return file paths.
    ///
    /// In the method, multiple threads will be created to concurrently generate dylibs
    /// under different package paths.
    ///
    /// This method will generate “.out” and ".ll" files, and return the file paths of
    /// the generated files in Vec<String>.
    pub fn gen_dylibs(
        &self,
        program: ast::Program,
        scope: ProgramScope,
        plugin_agent: u64,
        entry_file: &String,
    ) -> Vec<String> {
        // gen bc or ll_file
        let path = std::path::Path::new(LL_FILE);
        if path.exists() {
            std::fs::remove_file(path).unwrap();
        }
        for entry in glob::glob(&format!("{}*.ll", LL_FILE)).unwrap() {
            match entry {
                Ok(path) => {
                    if path.exists() {
                        std::fs::remove_file(path).unwrap();
                    }
                }
                Err(e) => println!("{:?}", e),
            };
        }

        let cache_dir = Path::new(&program.root)
            .join(".kclvm")
            .join("cache")
            .join(kclvm_version::get_full_version());
        if !cache_dir.exists() {
            std::fs::create_dir_all(&cache_dir).unwrap();
        }
        let mut compile_progs: IndexMap<
            String,
            (
                ast::Program,
                IndexMap<String, IndexMap<String, String>>,
                PathBuf,
            ),
        > = IndexMap::default();
        for (pkgpath, modules) in program.pkgs {
            let mut pkgs = HashMap::new();
            pkgs.insert(pkgpath.clone(), modules);
            let compile_prog = ast::Program {
                root: program.root.clone(),
                main: program.main.clone(),
                pkgs,
                cmd_args: vec![],
                cmd_overrides: vec![],
            };
            compile_progs.insert(
                pkgpath,
                (compile_prog, scope.import_names.clone(), cache_dir.clone()),
            );
        }
        let pool = ThreadPool::new(self.thread_count);
        let (tx, rx) = channel();
        let prog_count = compile_progs.len();
        // let temp_entry_file = temp_file();
        for (pkgpath, (compile_prog, import_names, cache_dir)) in compile_progs {
            let tx = tx.clone();
            let temp_entry_file = entry_file.clone();
            pool.execute(move || {
                let root = &compile_prog.root;
                let is_main_pkg = pkgpath == kclvm_ast::MAIN_PKG;
                // The main package does not perform cache reading and writing,
                // and other packages perform read and write caching. Because
                // KCL supports multi-file compilation, it is impossible to
                // specify a standard entry for these multi-files and cannot
                // be shared, so the cache of the main package is not read and
                // written.
                let dylib_path = if is_main_pkg {
                    let file = PathBuf::from(&temp_entry_file);
                    lock_ll_file_and_gen_dylib(&compile_prog, import_names, &file, &plugin_agent)
                } else {
                    let file = cache_dir.join(&pkgpath);
                    // Read the dylib cache
                    let dylib_relative_path: Option<String> =
                        load_pkg_cache(root, &pkgpath, CacheOption::default());
                    match dylib_relative_path {
                        Some(dylib_relative_path) => {
                            if dylib_relative_path.starts_with('.') {
                                dylib_relative_path.replacen(".", root, 1)
                            } else {
                                dylib_relative_path
                            }
                        }
                        None => {
                            let dylib_path = lock_ll_file_and_gen_dylib(
                                &compile_prog,
                                import_names,
                                &file,
                                &plugin_agent,
                            );
                            let dylib_relative_path = dylib_path.replacen(root, ".", 1);
                            save_pkg_cache(
                                root,
                                &pkgpath,
                                dylib_relative_path,
                                CacheOption::default(),
                            );
                            dylib_path
                        }
                    }
                };
                tx.send(dylib_path)
                    .expect("channel will be there waiting for the pool");
            });
        }
        rx.iter().take(prog_count).collect::<Vec<String>>()
    }
}

fn lock_ll_file_and_gen_dylib(
    compile_prog: &Program,
    import_names: IndexMap<String, IndexMap<String, String>>,
    file: &PathBuf,
    plugin_agent: &u64,
) -> String {
    // ll_file: file_name
    // ll_path: file_name.ll
    // dylib_path: file_name.dll.lib or file_name.dylib or file_name.so
    let ll_file = file.to_str().unwrap();
    let ll_path = format!("{}.ll", ll_file);
    let dylib_path = format!("{}{}", ll_file, Command::get_lib_suffix());

    // Locking "*.ll" file for parallel code generation
    let mut ll_path_lock = fslock::LockFile::open(&format!("{}.lock", ll_path)).unwrap();
    ll_path_lock.lock().unwrap();

    // Clean "*.ll" file path
    clean_ll_path(&ll_path);

    // gen code
    emit_code(
        compile_prog,
        import_names,
        &EmitOptions {
            from_path: None,
            emit_path: Some(ll_file),
            no_link: true,
        },
    )
    .expect("Compile KCL to LLVM error");

    // assemble dylib
    let mut cmd = Command::new(*plugin_agent);
    let gen_dylib_path = cmd.run_clang_single(&ll_path, &dylib_path);

    // Clean "*.ll" file path
    clean_ll_path(&ll_path);

    // unlock "*.ll" file
    ll_path_lock.unlock().unwrap();

    return gen_dylib_path;
}

// Clean "*.ll" file path
fn clean_ll_path(ll_path: &String) {
    if Path::new(ll_path).exists() {
        std::fs::remove_file(&ll_path).unwrap();
    }
}
